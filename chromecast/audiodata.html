<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width">

    <title>decodeAudioData example</title>

    <link rel="stylesheet" href="../css/styles.css">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>

<body>

<div id="visualizer"></div>

<h1>Testing</h1>

<script>

    var prefix = (function () {
        var styles = window.getComputedStyle(document.documentElement, ''),
                pre = (Array.prototype.slice
                        .call(styles)
                        .join('')
                        .match(/-(moz|webkit|ms)-/) || (styles.OLink === '' && ['', 'o'])
                        )[1],
                dom = ('WebKit|Moz|MS|O').match(new RegExp('(' + pre + ')', 'i'))[1];
        return {
            dom: dom,
            lowercase: pre,
            css: '-' + pre + '-',
            js: pre[0].toUpperCase() + pre.substr(1)
        };
    })();

</script>


<script src="../js/libs/q.min.js"></script>
<script src="../js/libs/underscore-min.js"></script>
<script src="../js/libs/bean.min.js"></script>
<script src="../js/app/utils.js"></script>

<script src="visualizer.js"></script>
<script src="bars.js"></script>
<script src="queue.js"></script>


<script>

    var options = {
        playing: true
    };

    var staticAudioAnalyzer = {

        audioCtx: '',
        analyser: '',
        audioDataTimer: '',
        playbackRate: 1,

        getData: function(audioSrc, framerate) {

            return Q.Promise(function(resolve, reject, notify) {
                var myBuffer;
                var request = new XMLHttpRequest();
                var songLength;
                var source;
                var analyser;

                this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();

                analyser = this.audioCtx.createAnalyser();
                source = this.audioCtx.createBufferSource();

                request.open('GET', audioSrc, true);

                request.responseType = 'arraybuffer';

                request.onload = function() {
                    var response = request.response;
                    console.log(response)

                    this.audioCtx.decodeAudioData(response, function(buffer) {

                        myBuffer = buffer;
                        songLength = buffer.duration;
                        source.buffer = myBuffer;
                        source.playbackRate.value = this.playbackRate;
                        source.volume = 0.01;
                        source.connect(this.audioCtx.destination);
                        source.connect(analyser);
                        source.loop = true;
                        source.start(0);

                        b = source;


                        console.log(this, analyser, framerate, songLength, resolve, notify);

                        this.analyze(analyser, framerate, songLength, resolve, notify);

                    }.bind(this), function(e){console.warn("Error with decoding audio data" + e.err);});


                }.bind(this);

                if (options.playing) { //Used for debugging
                    request.send();
                }

            }.bind(this));

        },

        analyze: function(analyser, framerate, songLength, resolve, notify) {
            var audioData = [];

            var lengthOfRealSecond = 1000;
            var lengthOfSimulatedSecond = 1000 / this.playbackRate;
            var lengthOfSimulatedFrame = lengthOfSimulatedSecond / framerate;
            var numberOfSimulatedSeconds = songLength * lengthOfSimulatedSecond;
            var simulatedFrameCounter = 0;
            var numberOfRealSecondsPerPacket = 1;
            var lengthOfSimulatedFramePacket = framerate * numberOfRealSecondsPerPacket;

            clearInterval(this.audioDataTimer);

            this.audioDataTimer = setInterval(function() {

                if (simulatedFrameCounter < numberOfSimulatedSeconds) {
                    analyser.fftSize = 256;
                    var bufferLength = analyser.frequencyBinCount;
                    var dataArray = new Uint8Array(bufferLength);
                    analyser.getByteFrequencyData(dataArray);

//                    var string = float32ToArray(dataArray).join('|');

                    audioData.push(dataArray);
                    simulatedFrameCounter++;

                    if (simulatedFrameCounter % lengthOfSimulatedFramePacket === 0) {
                        console.log(audioData)
                        notify(audioData);
                        audioData = [];
                    }

                } else {
                    resolve(audioData);
                    clearInterval(this.audioDataTimer);
                }

//                if (simulatedFrameCounter % 5 === 0) {
//                    resolve(audioData);
////                    clearInterval(this.audioDataTimer);
//                }

            }.bind(this), lengthOfSimulatedFrame);
        }

    };

    var analyserDeferred = staticAudioAnalyzer.getData('audio.mp3', 60);

    analyserDeferred.then(
        function(response) {
            console.log('Response',response);
        }, function(err) {
            console.log('Error', err);
        }, function(progress) {
                PUBNUB_demo.publish({
                    channel: 'deasdfasdf',
                    message: progress
                });
//                console.log(progress)
//            console.log('Progress', progress);
        }
    );


    function roughSizeOfObject( object ) {

        var objectList = [];
        var stack = [ object ];
        var bytes = 0;

        while ( stack.length ) {
            var value = stack.pop();

            if ( typeof value === 'boolean' ) {
                bytes += 4;
            }
            else if ( typeof value === 'string' ) {
                bytes += value.length * 2;
            }
            else if ( typeof value === 'number' ) {
                bytes += 8;
            }
            else if
                    (
                    typeof value === 'object'
                            && objectList.indexOf( value ) === -1
                    )
            {
                objectList.push( value );

                for( var i in value ) {
                    stack.push( value[ i ] );
                }
            }
        }
        return bytes;
    }

    Queue.init();

</script>


</body>
s
</html>